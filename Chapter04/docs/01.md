# 1. 사라진 SQLEXCEPTION

- 3장에서 JdbcTemplate을 적용하면서 `throws SQLException` 선언이 사라졌다.

## 1.1 초난감 예외처리

### 예외 블랙홀

```
try {
    ...
} 
catch (Exception e) {
}
```

- 예외처리를 하고 catch 블록에서 아무 것도 하지 않는 경우가 존재한다.
- 이는 예외가 발생했어도 무시하고 진행하기 때문에 매우 위험하다.
- 오작동이 일어나기 시작하면 너무 늦고 설령 알았다 하더라도 찾기도 힘들다.

```
try { ... }
catch (Exception e) {
    System.out.println(e);
}
```

```
try { ... }
catch (Exception e) {
    e.printStackTrace();
}
```

- 메시지를 그냥 출력하는 것도 좋지 않다.
- 메시지가 바로 묻힐 가능성이 높으며, 운영서버에 올라갔다면 콘솔 로그를 계속 모니터링하지 않는 이상 알아채기 어렵다.
- 메시지 출력 != 예외 처리

```
try { ... }
catch (Exception e) {
    e.printStackTrace();
    System.exit(1);
}
```
- 모든 예외는 적절하게 복구되거나 작업을 중단시키고 운영자 또는 개발자에게 통보되어야 한다.
- 실전에서 이렇게 만들면 안 되지만 차라리 이렇게 만드는 게 알기 쉬울 것이다.

### 무의미하고 무책인한 throws

- 예외를 처리할 방법이 없거나 이름이 긴 예외를 매번 throws로 선언하기 귀찮아지면 `throws Exception`으로 처리하는 경우도 종종 볼 수 있다.
- 이는 정확한 예외가 무엇인지 알 수 없게 된다.

## 1.2 예외의 종류와 특징

- 자바에서는 throw를 통해 발생시킬 수 있는 예외가 세 가지 있다.
    1. Error: 시스템에 비정상적인 상황이 발생.
    2. Exception과 체크 예외: RuntimeException이 아닌 Exception.
    3. RuntimeException과 언체크/런타임 예외
    
## 1.3 예외처리 방법

### 예외 복구

- 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것.

### 예외처리 회피

- 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것.
- 예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다.
- 콜백/템플릿처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 확신이 있어야 한다.

### 예외 전환

- 예외를 복구해서 정상적인 상태로 만들 수 없는 경우 예외를 메서드 밖으로 던지는 것.
- 그대로 넘기는 게 아닌 적절한 예외로 전환해서 던진다.
- 예외 전환이 목적은 두 가지로 볼 수 있다.
    1. 내부에서 발생한 예외를 그대로 던지는 것이 적절한 의미를 부여하지 못 하는 경우, 의미를 분명하게 해주는 예외로 바꿔주기 위해.
    2. 예외를 처리하기 쉽고 단순하게 만들기 위해 포장하는 것. (복구 못할 체크 예외를 런타임 예외로 바꿔주기 등)
    
## 1.4 예외처리 전략

### 런타임 예외의 보편화

- 자바 엔터프라이즈 서버환경에서 사용자가 수많은 요청을 보내고 각 요청은 독립적인 작업으로 취급한다.
- 따라서 하나의 요청을 처리하는 중에 예외가 발생하면 해당 작업만 중단하면 된다.
- 예외가 발생했을 때 사용자와 커뮤니케이션하면서 예외상황을 복구할 방법이 없다.
- 대개는 복구 불가능한 상황이고 RuntimeException 등으로 포장해야 하니 아예 API 차원에서 런타임 예외를 던지도록 만든다.

### add() 메서드의 예외처리

- SQLException은 복구 불가능한 상황이므로 차라리 런타임 예외로 포장해서 던지는 편이 좋다.
- DuplicatedUserIdException을 체크 예외로 둬야 하는 것은 아니다. 어디에서든 이 예외를 잡아서 처리할 수 있다면 런타임 예외로 만드는 것도 좋다.

```java
public class DuplicatedUserIdException extends RuntimeException {
    public DuplicatedUserIdException(Throwable cause) {
        super(cause);
    }
}
```

```java
public class ExampleDao {
    // ...
    public void add() throws DuplicatedUserIdException {
        try {
            // ...
        } catch(SQLException e) {
            if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY)
                throw new DuplicatedUserIdException(e);
            else    
                throw new RuntimeException(e);
        }
    }
    // ...
}
```

### 애플리케이션 예외

- 런타임 예외 중신 전략은 낙관적인 예외처리 기법이다.
- 반면 애플리케이션 자체 로직에 의해 의도적으로 발생시키고, 반드시 처리하도록 만드는 예외가 있는데, 이를 `애플리케이션 예외`라고 한다.
- 예를 들어, 사용자가 은행계좌로부터 잔고 이상을 출금하려고 한다면 이를 다루는 메서드 설계는 다음과 같이 두 가지다.
    1. 정상적인 출금처리와 잔고 부족의 반환값을 다른 종류로 되돌려주는 것이다.
    2. 정상적인 흐름을 따라는 코드는 두고, 잔고 부족 같은 예외상황에서는 비지니스적인 의미를 지니는 예외를 던지도록 한다. 
- 2번의 경우 코드 이해도 편하고 번거롭게 if문을 남발하여 대비하지 않아도 된다.
- 이 때 사용하는 예외는 의도적으로 체크 예외로 만든다.

---
[목록](./index.md)
