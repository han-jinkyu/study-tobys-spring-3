# 3. 애플리케이션 아키텍처

- 클라이언트와 백엔드 시스템 종류, 사용 기술, 연동 방법을 결정했다면 시스템 레벨 아키텍처는 대략 구성됐다.
- 다음으로 결정할 사항은 **스프링 웹 애플리케이션의 아키텍처**다.
- 아키텍처란 단순한 정의로는 **어떤 경계 안에 있는 내부 구성요소가 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것**이다.
  
## 3.1 계층형 아키텍처

- 성격이 다른 모듈이 강하게 결합되어 있으면 한 가지로 이유로 변경이 일어날 때 상관 없는 요소도 영향을 받는다.
- 따라서 인터페이스와 같은 유연한 경계를 만들고 분리하거나 모아주는 작업이 필요하다.

### 아키텍처와 SoC

- 지금까지는 DI 컨테이너를 통해 오브젝트끼리 직접적인 관계를 맺지 못하게 유연한 설계와 구현 전략을 사용하였다.
- 이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에도 동일하게 적용할 수 있다.
- 애플리케이션을 구성하는 오브젝트를 비슷한 성격과 책임을 가진 것끼리 묶을 수 있다.
    - 예를 들면 데이터 액세스 로직을 담당하는 DAO
    - 혹은 비즈니스 로직을 구현해놓은 비즈니스 서비스 오브젝트
- 이렇게 분리한 각 오브젝트는 독자적으로 개발과 테스트가 가능하다.
- 또한 전체를 이해하기도 상대적으로 쉽다.
- 이렇게 책임과 성격이 다른 것을 크게 그룹을 만들어 분리하는 것을 **계층형 아키텍처(layered architecture)**라 한다.
- 또는 계층이라는 의미를 가진 티어(tier)를 사용하여 **멀티 티어 아키텍처**라 한다.
- 보통 웹 기반 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 가지므로 **3계층(3-tier 또는 3-layer) 애플리케이션**이라 한다.

### 3계층 아키텍처와 수직 계층

1. 데이터 액세스 계층
    - 데이터 액세스 계층은 DAO 계층이라고도 불린다. DAO 패턴을 보편적으로 사용하기 때문이다.
    - 또한 DB 외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하여 **EIS(Enterprise Information System) 계층**이라고도 한다.
    - 외부 시스템을 호출해서 서비스를 이용하는 것은 기반(infrastructure) 계층으로 분류하기도 한다.
    - 사용 기술에 따라 다시 세분화된 계층으로 구분된다.
    - 추상화 수준에 따른 구분이기 떄문에 수직적 계층이라 부르기도 한다.
    - `JdbcTemplate`을 사용하는 데이터 액세스 계층의 특징은 `JdbcTemplate`이 추상화를 위한 계층으로 사용돼 로우레벨 기반 계층에 존재하는 기능을 간접적으로 이용하게 만든다.
    - 추상화 계층은 필요하면 얼마든지 추가할 수 있는데, 새로운 추상 계층을 도입해 하위 계층의 종류가 다른 서비스를 일관된 방식으로 접근할 수 있게 하는 구조다.
    - 새로운 계층을 추가하면 코드에 지대한 영ㄹ향을 주기 때문에 신중해야 한다.
2. 서비스 계층
    - 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다.
    - 이는 객체지향적인 설계 기법이 적용된 코드를 통해 비즈니스 로직의 핵심을 담아내고, 쉽게 테스트하고 유연하게 확장할 수 있다.
    - 서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다.
    - 때론 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있다.
    - 서비스 계층은 특별한 경우가 아니면 추상화 수직 계층구조를 가질 필요가 없다.
    - 비즈니스 로직을 담은 **서비스 계층**과 엔터프라이즈 서비스를 제공하는 **기반 서비스 계층**은 혼동되기 쉬우니 주의해야 한다.
    - 기반 서비스 계층은 3계층 어디에서나 접근이 가능한 구조로 설정할 수 있다.
    - 스케쥴링이 필요한 경우는 기반 서비스 계층이 서비스 계층을 실행하는 경우도 있다.
    - 원칙적으로 서비스 계층이 기반 서비스 계층의 구현에 종속되면 안 된다.
    - 이상적인 서비스 계층은 데이터 액세스 계층이나 프레젠테이션 계층이 바뀌어도 그대로 유지되어야 한다.
3. 프레젠테이션 계층
    - 가장 복잡한 계층이며, 매우 다양한 기술과 프레임워크 조합을 가질 수 있다.
    - 따라서 프레젠테이션에서 사용할 기술과 구조를 선택하는 일은 간단하지 않다.
    - 엔터프라이즈 애플리케이션에서는 클라이언트 종류와 상관 없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다.
    - 스프링은 웹 기반 프레젠테이션 계층을 개발할 수 있는 전용 프레임워크를 제공한다.

### 계층형 아키텍처 설계의 원칙

- 오브젝트 관계에서 적용된 대부분의 객체지향 설계 원칙은 아키텍처 레벨에서도 동일하게 적용할 수 있다.
- 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다.
- 각 계층은 자신의 계층의 책임에만 충실해야 한다.
- 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 낮아진다.

```
public ResultSet findUsersByName(String name) throws SQLException;
```
- 위와 같은 메서드의 문제는 데이터 엑세스 계층의 기술과 역할을 다른 계층에 노출한다는 점이다.
- `ResultSet`을 다룰 때 발생하는 예외처리나 리소스 반환, DB 커넥션 종료 등의 작업을 맡아야 하는 것이다.
- 던져지는 예외 역시 특정 데이터 액세스 계층의 구현에 종속되는 강한 결합이 만들어진다.
- 강한 결합은 유연성이 떨어지는 결과를 낳고, 이로 인해 발생하는 문제와 성격이 유사하고 파장이 심각해진다.

```
public List<User> findUsersByName(String name) throws DataAccessException;
```

- 따라서 위와 같이 수정되어야 한다.
- `User`는 사용자 정보를 담는 단순 오브젝트이며, 특정 계층의 기술이나 구현에 종속되지 않는다.
- 예외 또한 특별한 경우에 전달되는 거라면 `DataAccessException` 같은 런타임 예외로 만들어야 한다.
- 또 다른 실수는 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것이다.
- 서블릿의 `HttpServletRequest`나 `HttpServletResponse`, `HttpSession` 같은 타입을 서비스 계층 메서드에 파라미터 타입으로 사용하면 안 된다.
- 어떤 경우라도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다.
- 그러므로 계층 사이의 호출은 인터페이스를 통해 이뤄져야 한다.
- 스프링의 DI는 기본적으로 오브젝트 사이의 관계를 다룬다.
- DI는 계층을 구분해주지 않기 때문에 빈 사이의 의존관계를 만들 떄 주의해야 한다.
    - 중간 계층을 건너뛰거나 아무 계층에서나 함부로 가져다 쓰는 일은 피해야 한다.

## 3.2 애플리케이션 정보 아키텍처

- 엔터프라이즈 시스템은 동시에 많은 작업이 빠르게 수행되어야 하기에, 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지한다.
- 애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스템에 분산돼 보관된다.
- 이렇게 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 중요한 기준이 된다.
- 엔터프라이즈 애플리케이션에 존재하는 정보를 **단순히 데이터로 다루는 경우**와 **오브젝트로 다루는 경우**로 구분할 수 있다.
- **데이터 중심 아키텍처**는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조다.
    - DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고, 그 값을 취급하는 코드를 만들어 사용자가 보는 화면과 연결해준다.
    - 핵심 비즈니스 로직을 어디에 많이 두는지에 따라 **DB에 무게를 두는 구조**와 **서비스 계층 코드에 무게를 두는 구조**로 구분할 수 있다.

### DB/SQL 중심의 로직 구현 방식

- 데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다.
- 검색조건은 SQL로 만들어지는데, SQL의 결과를 그대로 보여주기 때문에 SQL은 이미 화면에 어떤 식으로 출력될지 알고 있는 셈이다.
- 모든 계층의 코드는 업무에 종속되고, 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다.
- 대용량 데이터를 다룰 때 빠른 처리가 필요한 경우, 일부 로직을 PL/SQL과 같은 저장 프로시저 형태로 만들기도 한다.
    - 이런 개발 방법과 아키텍처는 자바 기술이 발전하기 이전의 엔터프라이즈 시스템에서 흔히 발견할 수 있는 형태다.
    - 장점으로는 초반에 개발하기 쉽다는 점이 있다. 
    - 하지만 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시킨다.
- 이런 코드는 항상 SQL과 그 결과에 종속되기 때문에 SQL의 변화가 일어나면 같이 변경돼야 한다.
- 겉으로 보기에 각 계층은 독립적으로 보이지만, 그 사이를 이동하는 데이터가 접착제 역할을 하여 강한 결합을 만들어낸다.
- 이런 개발 방식은 변화에 매우 취약하며, 각 계층이 긴밀하게 연결되어 중복을 제거하기도 쉽지 않다.
    - 로직을 DB와 SQL에 많이 담으면 담을수록 확장성이 떨어지며, 제한된 자원인 DB에 큰 부담을 준다.
    - 상대적으로 애플리케이션 서버는 쉽게 확장이 가능하며 서버 비용이 저렴해지고 있다.
- 따라서 로직을 DB보다 애플리케이션으로 가져오는 편이 유리하다.
    - 이는 비용도 저렴해지며 안정성도 높아지고, 코드를 검증하기도 매우 편하다.

### 거대한 서비스 계층 방식

- DB에서 가져온 데이터가 중심인 아키텍처이지만 DB에 로직을 두어 부하를 주는 단점을 피하는 방식은 **서비스 계층의 코드에서 처리하도록 만드는 것**이다.
- 많은 비즈니스 로직을 DB의 저장 프로시저나 SQL에서 서비스 계층으로 옮겨왔기에 애플리케이션 코드의 비중이 커진다.
- 하지만 그만큼 구조는 단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.
- DAO에서는 단순한 결과를 돌려주며, 이 정보를 분석, 가공하는 건 서비스 계층 코드의 책임이 된다.
- DAO와 SQL은 상대적으로 단순해지고, 그중 일부는 여러 서비스 계층 코드에서 재사용이 가능해진다.
- 비즈니스 로직이 복잡해지면 서비스 코드도 복잡해진다.
- 업무 트랜잭션 단위로 서비스 계층 메서드가 만들어질 가능성이 높은데 그러다 보면 하나의 메서드가 거대해진다.
- 이런 접근 방법은 **거대한 서비스 계층(fat service layer)**을 만들게 된다.
    - 장점은 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기 쉽다는 점이다.
    - 또한 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다.
    - 단점은 데이터 액세스 계층의 SQL이 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다.
    - 따라서 계층간의 결합도가 여전히 커진다. 이는 비슷한 기능의 코드가 여러 메서드에 중복되는 결과를 낳는다.
- 데이터 중심 아키텍처의 특징은 계층 사이의 결합도가 높고 응집도는 떨어진다는 것이다.
- 처음엔 개발하기 편하지만 중복이 많아지고 장기적으로는 코드를 관리하고 발전시키기 힘들다.

## 3.3 오브젝트 중심 아키텍처

- 오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 **도메인 모델을 반영하는 오브젝트 구조를 만들어두고 각 계층 사이에서 정보를 전송하는 데 사용한다는 점**이다.
- 그래서 오브젝트 중심 아키텍처는 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다.
- 대개 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성이 높다.

### 데이터와 오브젝트

간단한 예를 통해 데이터와 오브젝트 방식을 비교해 본다.

- 어떤 업무를 분석해보니 카테고리와 상품이라는 두 가지 엔티티가 나왔다.
- 카테고리 하나에 여러 개의 상품이 포함되고, 각 상품은 하나의 카테고리에 소속된다. (1:N 관계)

```
|-----------------|             |-----------------|
|     Category    |             |     Product     |
|-----------------| <>--------- |-----------------|
| id, description | 1       0-* | id, name, price |
|-----------------|             |-----------------|
```

- 이를 DB 테이블로 만들면 Product 쪽에 Category와 관계를 만드는 외래키(Foreign Key)를 둬야 한다.

[Category]
| 필드명        | 타입          | 설정         |
|-------------|--------------|-------------|
| CategoryId  | int          | Primary Key |
| Description | varchar(100) | -           |

[Product]
| 필드명       | 타입          | 설정                    |
|------------|--------------|------------------------|
| ProductId  | int          | Primary Key            |
| Name       | varchar(100) | -                      |
| Price      | int          | -                      |
| CategoryId | int          | Foreign Key (Category) |

- 조건에 맞는 모든 카테고리와 상품 정보를 가져와서 화면에 출력하는 기능을 만든다고 가정하면, **데이터 중심 아키텍처**에선 SQL과 DB 관점에서 생각한다.
- 두 개의 정보를 조합해서 가져오는 방법으로 `JOIN`을 이용해 2차원 구조의 정보를 만든다.
- 따라서 DAO에서 다음과 같은 SQL을 사용하게 만든다.

```sql
SELECT c.categoryid, c.description, p.productid, p.name, p.price 
FROM product p
JOIN category c 
ON p.categoryid = c.categoryid
```

- 맵에 필드 이름과 값을 함께 담고 맵의 리스트를 돌려주게 만들 것이다.
- DAO에서는 JDBC로 SQL을 실행하고 받은 결과를 서비스 계층으로 넘겨준다.
- 서비스 계층에 전달되는 것은 `List<Map<String, Object>>` 타입이다.
- 이 결과를 사용하는 계층의 코드에선 안에 담긴 내용을 알 수 없다.
- 이는 DAO에서 SQL을 변경하거나 필드 개수, 순서, 이름을 바꾸면 다른 계층의 코드의 변경을 초래한다.
- 즉 데이터 중심 아키텍처는 모든 계층의 코드가 DAO가 만드는 SQL 결과에 의존하게 된다.
- 반면 **오브젝트 방식**에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다.
- 따라서 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다.
- 먼저 도메인 모델의 구조를 따라 의미 있는 타입과 정보를 가진 클래스를 정의한다.

```java
public class Category {
    int categoryid;
    String description;
    Set<Product> products;  // 0-N개의 Product를 참조
    // ...
}

public class Product {
    int productid;
    String name;
    int price;
    Category category;      // 1개의 Category를 참조
    // ...
}
```

- 이 구조는 애플리케이션 어디에서도 사용될 수 있는 일관된 형식의 도메인 정보를 담고 있다.
- 도메인 모델을 반영하는 오브젝트를 사용하면 자바 언어의 특성을 최대한 활용할 수 있도록 정보를 가공할 수 있다.
- 대표적으로 오브젝트 사이의 관계를 나타내는 방법이 있다.
- RDB는 키의 조합으로 조인해서 의미 있는 관계를 만들지만, 자바는 레퍼런스 변수를 이용해 다른 오브젝트를 참조할 수 있다.
- 따라서 외래키가 존재하지 않고 레퍼런스 변수를 갖게 된다.
- 오브젝트 중심 방식에서는 테이블 정보와 그 관계를 유지한 채로 정확한 개수의 `Category` 오브젝트와 그에 대응하는 `Product` 오브젝트로 만들어 사용한다.
- 이렇게 도메인 모델을 따르는 오브젝트 구조를 만들려면 DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환할 필요가 있다.
- DAO는 자신이 DB에서 가져와 도메인 모델 오브젝트에 담아주는 정보가 어떻게 사용될지는 신경 쓰지 않아도 된다.
- 서비스 계층 또한 DAO에서 어떤 SQL을 사용했는지 몰라도 된다.
- 프레젠테이션 계층도 어떤 비즈니스 로직을 거졌는지 알 필요 없이 도메인 오브젝트를 활용해 필요한 정보를 출력하기만 하면 된다.

### 도메인 오브젝틀 사용하는 코드

- 오브젝트 중심 방식에서 비즈니스 로직 구현이 얼마나 간단하고 명확한지 살펴본다.
- 카테고리에 포함된 상품의 모든 가격을 계산해야 하는 로직이 필요하면 다음 메서드를 만들면 된다.

```
public int calcTotalOfProductPrice(Category cate) {
    int sum = 0;
    for (Product prd : cate.getProducts()) {
        sum += prd.getPrice();
    }
    return sum;
}
```

- 도메인 모델을 알고 있다면 위 메서드가 무슨 작업을 하는지 이해하기 쉽다.
- 테스트를 만들어 검증하기도 편하며 로직이 변경될 때 코드를 수정하기도 수월하다.
- 반면 데이터 중심 방식에서라면 이런 방식으로 재사용 가능한 메서드를 만들어 사용하기 어렵다.
- `Category` 내 `Product` 가격의 합을 계산하는 동일한 로직이지만 SQL을 통해 데이터를 어떻게 가져왔는지에 따라 처리하는 코드가 만들어지므로 코드에 중복이 발생한다.
- 오브젝트 구조로 정보를 갖고 있으면 활용이 편리하다. 자바에서는 `.`을 이용해 레퍼런스 변수를 따라가면 관련 정보를 손쉽게 이용할 수 있다.

```
int count = product.getCategory().getProducts().size();
```

- 테스트를 만드는 편리함에서도 큰 차이가 발생하는데, SQL에 담긴 로직은 복잡하고 불편하다.
- 반면 도메인 오브젝트를 코드는 간단히 테스트 값을 담은 도메인 오브젝트를 생성해서 쉽게 검증할 수 있다.

### 도메인 오브젝트 사용의 문제점

- 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 손해를 감수해야 될 수 있다.
- DAO는 도메인 오브젝트의 모든 필드 값을 채워서 전달하는데 드물게 사용되는 경우 낭비가 될 수 있다.
- 오브젝트 관계에도 문제가 있는데, 관계가 있는 오브젝트 마저 조회해서 들고 오는 경우 낭비가 될 수 있다.
- 이런 경우 관계가 있는 오브젝트가 필요한 경우와 아닌 경우를 구분해서 DAO를 만들 수 있으나, `NullPointerException`의 위험성이 있다.
- 이는 최적화를 고려해서 DAO를 작성하게 되므로, DAO가 어느 정도 사용되는지 파악해야 하고 DAO와 비즈니스 로직 코드의 결합도가 높아지는 문제가 생긴다.
- 이런 문제를 해결하기 위한 접근 방법은 여러 가지가 있다.
- **지연된 로딩(lazy loading)** 기법을 이용하면 최소한의 오브젝트 정보만 읽어두고 필요할 때 다이내믹하게 DB에서 읽어올 수 있다.
- 필드가 너무 많은 테이블이 있다면 자주 사용되는 것만 골라 별도 오브젝트로 정의하여 필요에 따라 구분해서 사용할 수 있다.
- 하지만 이는 DAO에 메서드를 추가해야 하고, 어느 DAO를 사용할지 서비스 계층에서 알아야 하기에 계층 사이의 결합이 발생한다.
- 가장 이상적인 방법은 JPA나 JDO, 하이버네이트와 같은 ORM 기술을 이용하는 것이다.
- 이런 데이터 액세스 기술은 기본적으로 지연된 로딩 기법 등을 제공하기에 도메인 오브젝트의 생성을 최적화할 수 있다.
- SQL 결과를 가지고 도메인 오브젝트를 채우는 등 복잡한 DAO 코드를 만들지 않아도 된다.
- 자주 변경되지 않으면서 많은 로직에서 참조하는 레퍼런스 테이블은 ORM이 제공하는 오브젝트 캐시에 담아두고 사용할 수 있다.
- 따라서 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 **ORM 같은 오브젝트 중심 데이터 액세스 기술을 사용**하길 권장한다.
- 도메인 오브젝트는 자바 오브젝트인데, 오브젝트는 데이터 저장은 물론, 내부 정보를 이용하는 기능도 있어야 한다.
- 클래스는 속성(attribute)와 행위(operation)의 조합이므로, 필드와 접근자, 수정자만으로는 반쪽짜리다.
- 가능다하면 이를 적극적으로 활용해야 하며 오브젝트 중심 아키텍처는 **오브젝트 활용 방법을 기준으로 다시 구분**해볼 수 있다.

### 빈약한 도메인 오브젝트 방식

- 도메인 오브젝트에 정보만 담겨 있고 정보를 활용하는 기능이 없다면, **빈약한(anemic) 오브젝트**라 부른다.
- 계층 사이의 독립성을 확보하기 위해 특정 계층에 종속되지 않으면서 애플리케이션 전반에 이용되는 오브젝트가 필요하고, 실제로 많이 사용된다.
- 그렇다면 도메인 오브젝트에 넣을 수 있는 기능은 어떤 것이 있는가?
    - 도메인 모델을 반영해 만들어진 오브젝트이므로, 기능이라고 하면 도메인의 비즈니스 로직이다.
- 그렇다면 빈약한 도메인 오브젝트 방식에선 비즈니스 로직은 어디에 존재하는가?
    - 서비스 계층에 존재한다.
    - 빈약한 도메인 오브젝트 방식은 데이터 중심 아키텍처의 거대 서비스 계층 구조와 비슷하다.
- 빈약한 도메인 오브젝트 방식의 한계는 거대 서비스 계층 방식과 유사하다.
- 이는 서비스 계층의 메서드에 대부분 비즈니스 로직이 들어 있어 로직의 재사용성이 떨어지고 중복 문제가 발생하기 쉽다.
- 하지만 비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3계층 구조의 특징을 잘 살려서 개발할 수 있는 유용한 아키텍처다.

### 풍성한 도메인 오브젝트 방식

- 빈약한 도메인 오브젝트의 단점을 개선하기 위한 **풍성한(rich) 도메인 오브젝트** 또는 **영리한(smart) 도메인 오브젝트** 방식이 있다.
- 어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있다.
- 이런 로직을 서비스 계층 코드가 아니라 도메인 오브젝트에 넣어주고 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것이다.

```java
public class Category {
    // ...
    List<Product> products;

    public int calcTotalOfProductPrice() {  // <- Category를 따로 받지 않아도 된다.
        int sum = 0;
        for (Product prd : this.products) { // <- 내부 정보를 활용해 로직을 수행한다.
            sum += prd.getPrice();
        }
        return sum;
    }
}
```

- 이렇게 만들면 서비스 계층의 메서드에 따로 만드는 경우보다 응집도가 높다. 데이터와 그것을 사용하는 기능이 한곳에 모여 있기 때문이다.
- 만약 `Category`의 상품 가격 계산 작업이 필요하다면...
    - 그때마다 `Category` 오브젝트를 파라미터로 해서 `CategoryService` 를 호출하는 건 번거롭다.
    - 그 과정에서 `CategoryService`를 DI하는 것도 번거롭다.
    - 또한 다른 개발자가 `CategoryService`에 그런 기능이 있는지 몰라 같은 기능을 가진 코드를 만들 수도 있다.
- 만약 `InventoryService`를 개발하는데 `calcTotalOfProductPrice()`를 사용해야 한다면 DI를 해줘야 한다.

```java
public class InventoryService {
    private CategoryService categoryService;

    public void setCategoryService(CategoryService categoryService) {
        this.categoryService = categoryService;
    }

    public void complexInventoryAnalysis() {
        // ...
        int total = this.categoryService.calcTotalOfProductPrice(category);
        // ...
    }
}
```

- `Category`에 대한 계산 로직을 `Category` 오브젝트 안에 직접 넣어뒀다면 이런 번거로운 작업은 필요 없다.
- 비슷한 코드가 여기저기 비즈니스 로직에 중복돼서 나타나지도 않는다.

```java
public class InventoryService {
    public void compelxInventoryAnalysis() {
        // ...
        int total = category.calcTotalOfProductPrice();
        // ...
    }
}
```

- 풍성한 도메인 오브젝트 방식은 훨씬 간결하고 객체지향적이다.
- 객체지향 분석과 설계를 통해 만들어진 도메인 모델의 정보를 정적인 구조 뿐 아니라 동적인 동작 방식에도 적극 활용할 수 있다.
- 도메인 오브젝트에 비즈니스 로직을 넣는다고 해서 서비스 계층 오브젝트가 필요 없어지는 것은 아니다.
- 여러 종류의 도메인 오브젝트의 긴으을 조합해서 복잡한 비즈니스 로직을 만들었다면 서비스 계층 오브젝트에 두는 것이 좋다.
- 도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층, 서비스 계층 오브젝트에 접근할 수 없기에 서비스 계층이 필요하다.
- 도메인 오브젝트는 **스프링 컨테이너가 관리하는 빈이 아니기에** DAO 오브젝트를 DI 받을 수 없다.
- 서비스 계층은 도메인 오브젝트를 외부 리소스에서 가져오고, 변경된 정보나 새로 등록된 정보를 반영하는 동시에, 도메인 오브젝트가 갖고 있는 기능을 활욯해 로직을 처리해야 한다.
- 그렇다고 하여 빈약한 도메인 오브젝트 방식이 항상 나쁜 것은 아니다.
- 이상적인 도메인 오브젝트를 설계하고 사전에 내부 기능을 충분히 구현하지 않았다면 개발자는 혼란을 느낄 수도 있다.
- 충분히 선행되지 않고 공유되지 않았다면, 오히려 빈약한 도메인 오브젝트 방식이 혼란을 피할 수 있고 좋은 대안이 된다.
- 하지만 시간이 지나면서 시스템이 복잡해지면 단점이 드러날 수 있다.

### 도메인 계층 방식

- 도메인 오브젝트에 담긴 비즈니스 로직은 내부 데이터를 분석하거나, 정보를 변경, 생성하는 정도다.
- 이렇게 변경된 정보가 다시 DB 등에 반영되려면 서비스 계층 오브젝트의 부가적인 작업이 필요하다.
- 도메인 계층의 역할과 비중을 극대화하기 위해 등장한 것이 **도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되는 방식**이다.
- 도메인 오브젝트가 하나의 독립적인 계층을 이뤄 서비스 계층과 데이터 액세스 계층 사이에 존재하게 하는 것이다.
- 도메인 오브젝트가 독립된 계층을 이뤘기 때문에 기존 방식과는 다른 두 가지 특성을 지닌다.
    1. 도메인 종속적인 비즈니스 로직의 처리는 도메인 계층 오브젝트 내에서 진행된다는 것이다.
    2. 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다는 것이다.
- 도메인 오브젝트는 빈이 아니기 때문에 다른 빈을 DI 받을 수 없지만, 설정을 추가한다면 DI를 적용할 수 있다.
- 스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요하다.
- `AspectJ AOP`를 사용하면 일반 오브젝트에도 AOP 부가기능을 적용할 수 있다.
- **도메인 계층 방식**은 도메인 오브젝트에 많은 비즈니스 로직을 담아낼 수 있지만, 서비스 계층의 역할이 사라지는 건 아니다.
    - 특정 도메인 오브젝트에 담길 수 없는 작업은 서비스 계층에서 진행하는 것이 바람직하다.
    - 또는 도메인 계층을 거치지 않고 바로 데이터 액세스 계층으로부터 정보를 가져와 클라이언트에 제공하는 경우도 있다. 이럴 때 서비스 계층이 인터페이스 역할을 담당한다.
    - 또는 트랜잭션 경계를 설정하거나 특정 도메인 로직에 포함되지 않지만 애플리케이션에서 필요로 하는 기반 서비스를 이용해야 하는 작업을 위해 서비스 계층은 필요하다.
- 대신 서비스 계층의 비중과 규모는 작아진다. 복잡하지 않은 애플리케이션은 서비스 계층을 아예 제거할 수도 있다.
    - 이땐 트랜잭션 경계가 프레젠테이션 계층에서 최초로 호출되는 도메인 오브젝트의 메서드에 설정돼야 한다.
- 도메인 오브젝트가 독립적인 계층으로 만들 때 고려해야 할 사항이 있다.
    1. 여전히 모든 계층에서 도메인 오브젝트를 사용한다.
        - 모든 계층에서 도메인 오브젝트를 전달 받아 사용한다.
        - 단점은 확실한 가이드라인을 주고 따르지 않으면 함부로 사용하게 될 수 있다.
    2. 도메인 오브젝트가 도메인 계층을 벗어나지 못하게 한다.
        - 도메인 계층 밖으로 전달할 땐 별도로 정보 전달용 오브젝트에 내용을 복사해서 넘긴다.
        - 이를 DTO(Data Transfer Object)라고 한다.
- 도메인 계층은 기존 3계층과 비슷한 수준에서 독립적이지만, 매우 짧은 시간 동안만 존재했다가 사라지는 것을 반복한다.
- 상태정보를 담고 있기에 싱글톤이 될 수 없고, DAO나 컨트롤러, 스프링 외 라이브러리를 통해 만들어지기에 빈으로 등록이 불가하다.
- 그렇기 떄문에 특별한 방법으로 DI를 해줘야지만 다른 3계층의 빈들과 협력할 수 있다.
- 이런 여러 제약과 불편을 감수하면서 이 방식을 택하는 이유는 **매우 복잡하고 변경이 잦은 도메인을 가졌을 때**이다.
- 도메인 계층은 응집도가 매우 높아 단위 테스트를 작성하기 편리하다.
- 반면 그만큼 복잡하지 않은 애플리케이션이라면 이런 방식을 선택하는 것 자체가 과도한 부담을 줄 수 있다.

### DTO와 리포트 쿼리

- 오브젝트 중심 아키텍처라고 해서 애플리케이션 내의 모든 정보를 항상 도메인 오브젝트에 담을 필요는 없다.
- 도메인 계층을 벗어난 정보를 DTO에 담아 사용하기도 한다. 그 외 방법에서도 DTO의 사용이 꼭 필요한 경우가 있다.
- 대표적인 예는 리포트 쿼리(report query)라 불리는 DB 쿼리의 실행 결과를 담는 경우다.
    - 이는 종합 분석 리포트처럼 여러 테이블에 걸쳐 존재하는 자료를 분석하고 그에 따른 분석/통계 결과를 생성하는 쿼리라는 의미다.
    - 이런 쿼리의 실행 결과를 담을만한 적절한 도메인 오브젝트는 없기에 DTO나 맵(Map)에 담아서 전달해야 한다.
- 때론 DB의 쿼리 하나로 최종 결과를 만들어내기 힘들기 때문에 코드를 통해 데이터를 분석/가공하는 작업이 필요하다.
    - 최종 결과는 DTO나 맵, 컬렉션에 담겨서 전달되어야 한다.
- 때론 웹 서비스 등의 시스템과 자료를 주고받을 때 전송 규약에 맞춰 도메인 오브젝트에 담긴 정보를 가공해야 한다.
    - 이런 경우에도 DTO나 맵을 이용해 해당 형식에 맞도록 변경하는 작업이 필요하다.


## 3.4 스프링 애플리케이션을 위한 아키텍처 설계

- '계층구조를 어떻게 나눌 것인가'와 '애플리케이션 정보를 어떻게 다룰지를 결정하는 것'이 기본이 된다.
- 그 위에 각 계층에 사용될 구체적인 기술의 종류와 수직 추상화 계층의 도입, 세세한 기술적인 조건을 결정하는 일이 남았다.

### 계층형 아키텍처

- 3계층 구조는 스프링을 사용하는 엔터프라이즈 애플리케이션에서 가장 많이 사용되는 구조다.
- 다만 3계층이란 것은 논리적이고 개념적인 구분이며 꼭 오브젝트 단위로 나뉘는 것이 아님을 염두에 둬야 한다.
    - 예를 들어 서비스 계층이 필요 없을 만큼 비즈니스 로직이 단순하다면 서비스 계층과 데이터 액세스 계층을 통합할 수 있다.
    - 반대로 프레젠테이션 계층에 서비스 계층을 통합할 수도 있다. 다만 트랜잭션 경계가 애매하기 때문에 스프링에선 권장하지 않는다.
- 프레젠테이션 계층은 보통 MVC라는 이름으로 잘 알려진 패턴 또는 아키텍처를 사용한다.
- 스프링의 대표적인 프레젠테이션 기술도 `SpringMVC`라는 이름을 갖고 있다.
- 스프링은 MVC 중 가장 부담을 많이 지고 있는 컨트롤러에 해당하는 부분을 세분화하여 여러 단계의 오브젝트를 만들 수 있도록 설계됐다.
- 프레젠테이션 계층은 그 경계를 서버를 떠나서 클라이언트까지 확장하기도 한다.
- SOFEA(Service Oriented Front End Architecture)는 프레젠테이션 계층 코드가 클라이언트로 다운로드되어 동작하며 서버와 통신하는 구조로 만들어진다.
- 이때는 프레젠테이션 계층이 가진 인터페이스, 화면 흐름 제어, 서버와의 통신, 상태정보 유지 등을 클라이언트에 다운로드된 코드에서 대부분 담당한다.
- 스프링을 처음 학습한다면 **전통적인 서버 기반의 3계층 구조에 먼저 익숙해지는 것**이 좋다.

### 정보 전송 아키텍처

- 스프링의 기본 기술에 가장 알맞고 쉽게 적용 가능한 것은 오브젝트 중심 아키텍처의 도메인 오브젝트 방식이다.
- 빈약한 도메인 오브젝트 방식으로 시작하는 게 가장 쉽다.
- 도메인 오브젝트를 계층 간 정보 전송을 위해 사용하고, 이를 각 계층의 코드에서 활용한다.
    - DAO는 기술이 어떤 것이든 상관없이 서비스 계층에서 요청을 받거나 결과를 돌려줄 때 도메인 오브젝트 형태를 유지하게 한다.
    - 서비스 계층의 비즈니스 로직은 도메인 오브젝트를 이용해 작성하나, 간단한 기능은 도메인 오브젝트에 추가한다.
    - 프레젠테이션 계층에서도 이 도메인 오브젝트를 직접 활용한다.
- 이렇게 도메인 오브젝트를 사용해 애플리케이션 정보를 일관된 형태로 유지하는 게 스프링에 가장 잘 들어맞는 방식이다.
- DB와 SQL에 많은 비즈니스 로직을 담고 있는 레거시 시스템을 스프링으로 전환한다면, 일단 데이터 중심 아키텍처를 사용해도 무방하다.
    - 3계층의 기본 구조로 잘 분리하고 DB 중심 접근 방법을 이용해 기존에 만든 SQL을 재사용하낟.
    - 전환 작업을 마치고 검증이 끝난 후에 단계적으로 로직을 DB에서 애플리케이션으로 가져오고 오브젝트 중심으로 전환한다.
- 다음과 같다면 과감하게 도메인 계층 방식을 도입할 수 있다.
    - 객체지향적인 도메인 분석과 모델링에 자신 있다.
    - 도메인 오브젝트 설계와 구현, 독립적인 테스트를 자유롭게 적용할 수 있다.
- 다만 도메인 계층에 DI를 적용하기 위해 스프링의 고급 기술을 활용해야 하고 여러 가지 고려할 점이 많으므로 충분한 사전 학습과 검증이 선행돼야 한다.

### 상태 관리와 빈 스코프

- 아키텍처 설계에서 신경 써야 될 사항 중 하나는 **상태 관리**다.
- 크게는 사용자 로그인 세션 관리, 작게는 위저드 기능까지 애플리케이션은 하나의 HTTP 요청의 범위를 넘어서 유지해야 하는 상태정보가 있다.
- 엔터프라이즈 애플리케이션은 수많은 요청을 처리하기 위해 간단한 요청을 받아 결과를 돌려주는 방식으로 동작한다.
- 따라서 서버의 자원이 특정 사용자에게 일정하게 할당되지 않는다.
- 그렇기에 서버 기반 애플리케이션은 지속적으로 유지되는 상태를 갖지 않는다(stateless)는 특징이 있다.
- 하지만 어떤 식으로든 애플리케이션의 상태와 장시간 진행되는 작업정보는 유지돼야 한다.
- 이를 위해 웹 클라이언트에서 상태정보 또는 서버에 저장된 상태정보의 키 값 등을 전달해야 한다.
- 클라이언트와 서버 사이에 많은 정보를 계속해서 주고 받을 수는 없으므로 중요한 상태정보는 파일시스템, DB 등에 저장되기도 한다.
- 또는 제약이 있지만 HTTP 세션과 같은 서블릿 컨테이너가 제공하는 저장공간을 활용하기도 한다.
- 스프링은 기본적으로 **상태가 유지되지 않는 빈과 오브젝트를 사용하기**를 권한다. 웹의 생리에 알맞고 개발하기 쉽기 떄문이다.
- 반면 웹 클라이언트에 폼 정보를 출력하고 이를 수정하는 등의 작업을 위해 HTTP 세션을 적극 활용하기도 한다.
- 상태는 클라이언트, 백엔드나 일시적으로 서블릿의 HTTP 세션에 저장하는 게 대부분이다.
- 하지만 경우에 따라선 장기간 유지되며 중첩될 수 있는 상태를 다루는 **고급 상태 관리 기법**을 이용할 수 있다.
- 애플리케이션의 특징에 따라서 스프링을 이용해 상태유지(stateful) 스타일 애플리케이션을 만들 수도 있다.
- 스프링에서는 싱글톤 외에도 다른 스코프를 갖는 빈을 간단히 만들 수 있다.
- 이를 잘 활용하면 사용자별로 또는 단위 작업별로 독립적으로 생성되고 유지되는 오브젝트를 만들어 사용할 수 있다.

---
[Home](./index.md)
