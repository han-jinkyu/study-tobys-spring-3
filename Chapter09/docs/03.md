# 3. 애플리케이션 아키텍처

- 클라이언트와 백엔드 시스템 종류, 사용 기술, 연동 방법을 결정했다면 시스템 레벨 아키텍처는 대략 구성됐다.
- 다음으로 결정할 사항은 **스프링 웹 애플리케이션의 아키텍처**다.
- 아키텍처란 단순한 정의로는 **어떤 경계 안에 있는 내부 구성요소가 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것**이다.
  
## 3.1 계층형 아키텍처

- 성격이 다른 모듈이 강하게 결합되어 있으면 한 가지로 이유로 변경이 일어날 때 상관 없는 요소도 영향을 받는다.
- 따라서 인터페이스와 같은 유연한 경계를 만들고 분리하거나 모아주는 작업이 필요하다.

### 아키텍처와 SoC

- 지금까지는 DI 컨테이너를 통해 오브젝트끼리 직접적인 관계를 맺지 못하게 유연한 설계와 구현 전략을 사용하였다.
- 이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에도 동일하게 적용할 수 있다.
- 애플리케이션을 구성하는 오브젝트를 비슷한 성격과 책임을 가진 것끼리 묶을 수 있다.
    - 예를 들면 데이터 액세스 로직을 담당하는 DAO
    - 혹은 비즈니스 로직을 구현해놓은 비즈니스 서비스 오브젝트
- 이렇게 분리한 각 오브젝트는 독자적으로 개발과 테스트가 가능하다.
- 또한 전체를 이해하기도 상대적으로 쉽다.
- 이렇게 책임과 성격이 다른 것을 크게 그룹을 만들어 분리하는 것을 **계층형 아키텍처(layered architecture)**라 한다.
- 또는 계층이라는 의미를 가진 티어(tier)를 사용하여 **멀티 티어 아키텍처**라 한다.
- 보통 웹 기반 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 가지므로 **3계층(3-tier 또는 3-layer) 애플리케이션**이라 한다.

### 3계층 아키텍처와 수직 계층

1. 데이터 액세스 계층
    - 데이터 액세스 계층은 DAO 계층이라고도 불린다. DAO 패턴을 보편적으로 사용하기 때문이다.
    - 또한 DB 외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하여 **EIS(Enterprise Information System) 계층**이라고도 한다.
    - 외부 시스템을 호출해서 서비스를 이용하는 것은 기반(infrastructure) 계층으로 분류하기도 한다.
    - 사용 기술에 따라 다시 세분화된 계층으로 구분된다.
    - 추상화 수준에 따른 구분이기 떄문에 수직적 계층이라 부르기도 한다.
    - `JdbcTemplate`을 사용하는 데이터 액세스 계층의 특징은 `JdbcTemplate`이 추상화를 위한 계층으로 사용돼 로우레벨 기반 계층에 존재하는 기능을 간접적으로 이용하게 만든다.
    - 추상화 계층은 필요하면 얼마든지 추가할 수 있는데, 새로운 추상 계층을 도입해 하위 계층의 종류가 다른 서비스를 일관된 방식으로 접근할 수 있게 하는 구조다.
    - 새로운 계층을 추가하면 코드에 지대한 영ㄹ향을 주기 때문에 신중해야 한다.
2. 서비스 계층
    - 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다.
    - 이는 객체지향적인 설계 기법이 적용된 코드를 통해 비즈니스 로직의 핵심을 담아내고, 쉽게 테스트하고 유연하게 확장할 수 있다.
    - 서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다.
    - 때론 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있다.
    - 서비스 계층은 특별한 경우가 아니면 추상화 수직 계층구조를 가질 필요가 없다.
    - 비즈니스 로직을 담은 **서비스 계층**과 엔터프라이즈 서비스를 제공하는 **기반 서비스 계층**은 혼동되기 쉬우니 주의해야 한다.
    - 기반 서비스 계층은 3계층 어디에서나 접근이 가능한 구조로 설정할 수 있다.
    - 스케쥴링이 필요한 경우는 기반 서비스 계층이 서비스 계층을 실행하는 경우도 있다.
    - 원칙적으로 서비스 계층이 기반 서비스 계층의 구현에 종속되면 안 된다.
    - 이상적인 서비스 계층은 데이터 액세스 계층이나 프레젠테이션 계층이 바뀌어도 그대로 유지되어야 한다.
3. 프레젠테이션 계층
    - 가장 복잡한 계층이며, 매우 다양한 기술과 프레임워크 조합을 가질 수 있다.
    - 따라서 프레젠테이션에서 사용할 기술과 구조를 선택하는 일은 간단하지 않다.
    - 엔터프라이즈 애플리케이션에서는 클라이언트 종류와 상관 없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다.
    - 스프링은 웹 기반 프레젠테이션 계층을 개발할 수 있는 전용 프레임워크를 제공한다.

### 계층형 아키텍처 설계의 원칙

- 오브젝트 관계에서 적용된 대부분의 객체지향 설계 원칙은 아키텍처 레벨에서도 동일하게 적용할 수 있다.
- 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다.
- 각 계층은 자신의 계층의 책임에만 충실해야 한다.
- 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 낮아진다.

```
public ResultSet findUsersByName(String name) throws SQLException;
```
- 위와 같은 메서드의 문제는 데이터 엑세스 계층의 기술과 역할을 다른 계층에 노출한다는 점이다.
- `ResultSet`을 다룰 때 발생하는 예외처리나 리소스 반환, DB 커넥션 종료 등의 작업을 맡아야 하는 것이다.
- 던져지는 예외 역시 특정 데이터 액세스 계층의 구현에 종속되는 강한 결합이 만들어진다.
- 강한 결합은 유연성이 떨어지는 결과를 낳고, 이로 인해 발생하는 문제와 성격이 유사하고 파장이 심각해진다.

```
public List<User> findUsersByName(String name) throws DataAccessException;
```

- 따라서 위와 같이 수정되어야 한다.
- `User`는 사용자 정보를 담는 단순 오브젝트이며, 특정 계층의 기술이나 구현에 종속되지 않는다.
- 예외 또한 특별한 경우에 전달되는 거라면 `DataAccessException` 같은 런타임 예외로 만들어야 한다.
- 또 다른 실수는 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것이다.
- 서블릿의 `HttpServletRequest`나 `HttpServletResponse`, `HttpSession` 같은 타입을 서비스 계층 메서드에 파라미터 타입으로 사용하면 안 된다.
- 어떤 경우라도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다.
- 그러므로 계층 사이의 호출은 인터페이스를 통해 이뤄져야 한다.
- 스프링의 DI는 기본적으로 오브젝트 사이의 관계를 다룬다.
- DI는 계층을 구분해주지 않기 때문에 빈 사이의 의존관계를 만들 떄 주의해야 한다.
    - 중간 계층을 건너뛰거나 아무 계층에서나 함부로 가져다 쓰는 일은 피해야 한다.

## 3.2 애플리케이션 정보 아키텍처

- 엔터프라이즈 시스템은 동시에 많은 작업이 빠르게 수행되어야 하기에, 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지한다.
- 애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스템에 분산돼 보관된다.
- 이렇게 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 중요한 기준이 된다.
- 엔터프라이즈 애플리케이션에 존재하는 정보를 **단순히 데이터로 다루는 경우**와 **오브젝트로 다루는 경우**로 구분할 수 있다.
- **데이터 중심 아키텍처**는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조다.
    - DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고, 그 값을 취급하는 코드를 만들어 사용자가 보는 화면과 연결해준다.
    - 핵심 비즈니스 로직을 어디에 많이 두는지에 따라 **DB에 무게를 두는 구조**와 **서비스 계층 코드에 무게를 두는 구조**로 구분할 수 있다.

### DB/SQL 중심의 로직 구현 방식

- 데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다.
- 검색조건은 SQL로 만들어지는데, SQL의 결과를 그대로 보여주기 때문에 SQL은 이미 화면에 어떤 식으로 출력될지 알고 있는 셈이다.
- 모든 계층의 코드는 업무에 종속되고, 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다.
- 대용량 데이터를 다룰 때 빠른 처리가 필요한 경우, 일부 로직을 PL/SQL과 같은 저장 프로시저 형태로 만들기도 한다.
    - 이런 개발 방법과 아키텍처는 자바 기술이 발전하기 이전의 엔터프라이즈 시스템에서 흔히 발견할 수 있는 형태다.
    - 장점으로는 초반에 개발하기 쉽다는 점이 있다. 
    - 하지만 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시킨다.
- 이런 코드는 항상 SQL과 그 결과에 종속되기 때문에 SQL의 변화가 일어나면 같이 변경돼야 한다.
- 겉으로 보기에 각 계층은 독립적으로 보이지만, 그 사이를 이동하는 데이터가 접착제 역할을 하여 강한 결합을 만들어낸다.
- 이런 개발 방식은 변화에 매우 취약하며, 각 계층이 긴밀하게 연결되어 중복을 제거하기도 쉽지 않다.
    - 로직을 DB와 SQL에 많이 담으면 담을수록 확장성이 떨어지며, 제한된 자원인 DB에 큰 부담을 준다.
    - 상대적으로 애플리케이션 서버는 쉽게 확장이 가능하며 서버 비용이 저렴해지고 있다.
- 따라서 로직을 DB보다 애플리케이션으로 가져오는 편이 유리하다.
    - 이는 비용도 저렴해지며 안정성도 높아지고, 코드를 검증하기도 매우 편하다.

### 거대한 서비스 계층 방식

- DB에서 가져온 데이터가 중심인 아키텍처이지만 DB에 로직을 두어 부하를 주는 단점을 피하는 방식은 **서비스 계층의 코드에서 처리하도록 만드는 것**이다.
- 많은 비즈니스 로직을 DB의 저장 프로시저나 SQL에서 서비스 계층으로 옮겨왔기에 애플리케이션 코드의 비중이 커진다.
- 하지만 그만큼 구조는 단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.
- DAO에서는 단순한 결과를 돌려주며, 이 정보를 분석, 가공하는 건 서비스 계층 코드의 책임이 된다.
- DAO와 SQL은 상대적으로 단순해지고, 그중 일부는 여러 서비스 계층 코드에서 재사용이 가능해진다.
- 비즈니스 로직이 복잡해지면 서비스 코드도 복잡해진다.
- 업무 트랜잭션 단위로 서비스 계층 메서드가 만들어질 가능성이 높은데 그러다 보면 하나의 메서드가 거대해진다.
- 이런 접근 방법은 **거대한 서비스 계층(fat service layer)**을 만들게 된다.
    - 장점은 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기 쉽다는 점이다.
    - 또한 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다.
    - 단점은 데이터 액세스 계층의 SQL이 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다.
    - 따라서 계층간의 결합도가 여전히 커진다. 이는 비슷한 기능의 코드가 여러 메서드에 중복되는 결과를 낳는다.
- 데이터 중심 아키텍처의 특징은 계층 사이의 결합도가 높고 응집도는 떨어진다는 것이다.
- 처음엔 개발하기 편하지만 중복이 많아지고 장기적으로는 코드를 관리하고 발전시키기 힘들다.

## 3.3 오브젝트 중심 아키텍처

- 오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 **도메인 모델을 반영하는 오브젝트 구조를 만들어두고 각 계층 사이에서 정보를 전송하는 데 사용한다는 점**이다.
- 그래서 오브젝트 중심 아키텍처는 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다.
- 대개 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성이 높다.

### 데이터와 오브젝트

간단한 예를 통해 데이터와 오브젝트 방식을 비교해 본다.

- 어떤 업무를 분석해보니 카테고리와 상품이라는 두 가지 엔티티가 나왔다.
- 카테고리 하나에 여러 개의 상품이 포함되고, 각 상품은 하나의 카테고리에 소속된다. (1:N 관계)

```
|-----------------|             |-----------------|
|     Category    |             |     Product     |
|-----------------| <>--------- |-----------------|
| id, description | 1       0-* | id, name, price |
|-----------------|             |-----------------|
```

- 이를 DB 테이블로 만들면 Product 쪽에 Category와 관계를 만드는 외래키(Foreign Key)를 둬야 한다.

[Category]
| 필드명        | 타입          | 설정         |
|-------------|--------------|-------------|
| CategoryId  | int          | Primary Key |
| Description | varchar(100) | -           |

[Product]
| 필드명       | 타입          | 설정                    |
|------------|--------------|------------------------|
| ProductId  | int          | Primary Key            |
| Name       | varchar(100) | -                      |
| Price      | int          | -                      |
| CategoryId | int          | Foreign Key (Category) |

- 조건에 맞는 모든 카테고리와 상품 정보를 가져와서 화면에 출력하는 기능을 만든다고 가정하면, **데이터 중심 아키텍처**에선 SQL과 DB 관점에서 생각한다.
- 두 개의 정보를 조합해서 가져오는 방법으로 `JOIN`을 이용해 2차원 구조의 정보를 만든다.
- 따라서 DAO에서 다음과 같은 SQL을 사용하게 만든다.

```sql
SELECT c.categoryid, c.description, p.productid, p.name, p.price 
FROM product p
JOIN category c 
ON p.categoryid = c.categoryid
```

- 맵에 필드 이름과 값을 함께 담고 맵의 리스트를 돌려주게 만들 것이다.
- DAO에서는 JDBC로 SQL을 실행하고 받은 결과를 서비스 계층으로 넘겨준다.
- 서비스 계층에 전달되는 것은 `List<Map<String, Object>>` 타입이다.
- 이 결과를 사용하는 계층의 코드에선 안에 담긴 내용을 알 수 없다.
- 이는 DAO에서 SQL을 변경하거나 필드 개수, 순서, 이름을 바꾸면 다른 계층의 코드의 변경을 초래한다.
- 즉 데이터 중심 아키텍처는 모든 계층의 코드가 DAO가 만드는 SQL 결과에 의존하게 된다.
- 반면 **오브젝트 방식**에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다.
- 따라서 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다.
- 먼저 도메인 모델의 구조를 따라 의미 있는 타입과 정보를 가진 클래스를 정의한다.

```java
public class Category {
    int categoryid;
    String description;
    Set<Product> products;  // 0-N개의 Product를 참조
    // ...
}

public class Product {
    int productid;
    String name;
    int price;
    Category category;      // 1개의 Category를 참조
    // ...
}
```

- 이 구조는 애플리케이션 어디에서도 사용될 수 있는 일관된 형식의 도메인 정보를 담고 있다.
- 도메인 모델을 반영하는 오브젝트를 사용하면 자바 언어의 특성을 최대한 활용할 수 있도록 정보를 가공할 수 있다.
- 대표적으로 오브젝트 사이의 관계를 나타내는 방법이 있다.
- RDB는 키의 조합으로 조인해서 의미 있는 관계를 만들지만, 자바는 레퍼런스 변수를 이용해 다른 오브젝트를 참조할 수 있다.
- 따라서 외래키가 존재하지 않고 레퍼런스 변수를 갖게 된다.
- 오브젝트 중심 방식에서는 테이블 정보와 그 관계를 유지한 채로 정확한 개수의 `Category` 오브젝트와 그에 대응하는 `Product` 오브젝트로 만들어 사용한다.
- 이렇게 도메인 모델을 따르는 오브젝트 구조를 만들려면 DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환할 필요가 있다.
- DAO는 자신이 DB에서 가져와 도메인 모델 오브젝트에 담아주는 정보가 어떻게 사용될지는 신경 쓰지 않아도 된다.
- 서비스 계층 또한 DAO에서 어떤 SQL을 사용했는지 몰라도 된다.
- 프레젠테이션 계층도 어떤 비즈니스 로직을 거졌는지 알 필요 없이 도메인 오브젝트를 활용해 필요한 정보를 출력하기만 하면 된다.

### 도메인 오브젝틀 사용하는 코드

- 오브젝트 중심 방식에서 비즈니스 로직 구현이 얼마나 간단하고 명확한지 살펴본다.
- 카테고리에 포함된 상품의 모든 가격을 계산해야 하는 로직이 필요하면 다음 메서드를 만들면 된다.

```
public int calcTotalOfProductPrice(Category cate) {
    int sum = 0;
    for (Product prd : cate.getProducts()) {
        sum += prd.getPrice();
    }
    return sum;
}
```

- 도메인 모델을 알고 있다면 위 메서드가 무슨 작업을 하는지 이해하기 쉽다.
- 테스트를 만들어 검증하기도 편하며 로직이 변경될 때 코드를 수정하기도 수월하다.
- 반면 데이터 중심 방식에서라면 이런 방식으로 재사용 가능한 메서드를 만들어 사용하기 어렵다.
- `Category` 내 `Product` 가격의 합을 계산하는 동일한 로직이지만 SQL을 통해 데이터를 어떻게 가져왔는지에 따라 처리하는 코드가 만들어지므로 코드에 중복이 발생한다.
- 오브젝트 구조로 정보를 갖고 있으면 활용이 편리하다. 자바에서는 `.`을 이용해 레퍼런스 변수를 따라가면 관련 정보를 손쉽게 이용할 수 있다.

```
int count = product.getCategory().getProducts().size();
```

- 테스트를 만드는 편리함에서도 큰 차이가 발생하는데, SQL에 담긴 로직은 복잡하고 불편하다.
- 반면 도메인 오브젝트를 코드는 간단히 테스트 값을 담은 도메인 오브젝트를 생성해서 쉽게 검증할 수 있다.

---
[Home](./index.md)
