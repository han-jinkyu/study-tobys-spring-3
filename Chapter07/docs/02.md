# 2. 인터페이스의 분리와 자기참조 빈

## 2.1 XML 파일 매핑

- 스프링의 XML 설정파일에서 `<bean>` 태그 안에 SQL 정보를 넣어놓고 사용하는 건 좋지 않다.
- SQL을 저장해두는 전용 포맷을 가진 독립적인 파일을 이용하는 것이 좋다.
- 검색용 키와 SQL 문장 두 가지를 담을 수 있는 간단한 XML 문서를 설계해보고, XML 파일에서 SQL을 읽어뒀다가 DAO에 제공하는 SQL 서비스 구현 클래스도 만들어본다.

### JAXB

- 자바에서 XML에 담긴 정보를 파일에서 읽어올 때 사용하는 방법 중 하나인 `JAXB(Java Architecture for XML Binding)`를 이용해본다.
- DOM과 같은 전통적인 XML API와 비교했을 때의 장점은 **XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑**해준다는 점이다.
- 또한 XML 문서의 구조를 정의한 스키마를 이용해서 매핑할 오브젝트의 클래스까지 자동으로 만들어주는 컴파일러도 제공한다.

### SQL 맵을 위한 스키마 작성과 컴파일

- SQL 정보는 키와 SQL의 목록으로 구성된 맵 구조로 만들어두면 편리하다. 다음과 같이 키와 SQL 정보를 담은 `<sql>` 태그를 가진 XML 문서를 사용한다.

```xml
<sqlmap>
    <sql key="userAdd">insert into users(...) ...</sql>
    <sql key="userGet">select * from users ...</sql>
</sqlmap>
```

- 위와 같은 XML 문서의 구조를 정의하는 스키마를 만들어본다. 저장 위치는 루트이며, 파일명은 `sqlmap.xsd`로 한다.

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<schema xmlns="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.epril.com/sqlmap"
        xmlns:tns="http://www.epril.com/sqlmap" elementFormDefault="qualified">

    <element name="sqlmap"> <!-- <sqlmap> 엘리먼트를 정의한다 -->
        <complexType>
            <sequence>
                <!-- maxOccurs: 최대 사용 개수 지정 -->
                <element name="sql" maxOccurs="unbounded" type="tns:sqlType" />
            </sequence>
        </complexType>
    </element>

    <complexType name="sqlType"> <!-- <sql>에 대한 정의를 시작한다 -->
        <simpleContent>
            <extension base="string">   <!-- SQL 문장을 넣을 스트링 타입을 정의한다 -->
                <attribute name="key" use="required" type="string" />
            </extension>
        </simpleContent>
    </complexType>
</schema>
```

- 이렇게 만든 스키마 파일을 저장하고 JAXB 컴파일러로 컴파일해본다. 
- 컴파일할 떄는 자동으로 생성되는 바인딩용 클래스들이 위치할 패키지 이름을 제공해야 한다. `sqlservice` 패키지 밑에 `jaxb` 패키지를 추가한다.
- 그리고 다음 명령을 사용해 컴파일한다. 
    - Java 11부터는 제거되었기 때문에 다른 방법을 참조한다. [참조 사이트](https://www.jesperdj.com/2018/09/30/jaxb-on-java-9-10-11-and-beyond/)
    - 이 프로젝트는 메이븐을 사용하지 않으므로 `JAXB reference implementation standalone distribution` 직접 다운로드 받아 사용한다.
    - `jaxb-ri.zip`을 다운로드 받아서 `bin/xjc.sh`로 실행한다.

```
$ xjc -p springbook.user.sqlservice.jaxb sqlmap.xsd -d src
```

- **[에러 발생]** => 'http://www.epril.com/sqlmap'이 열리지 않으므로 위의 실습을 할 수가 없음. 따라서 내용을 정리하는 수준으로 끝내기로 함.

```xml
<!-- 추가할 의존성 -->
<dependency>
    <groupId>org.glassfish.jaxb</groupId>
    <artifactId>jaxb-runtime</artifactId>
</dependency>
```

- 직접 클래스를 작성하기로 하였다. (`Sqlmap`, `SqlType`)

```java
package springbook.user.sqlservice.jaxb;

import javax.xml.bind.annotation.*;
import java.util.ArrayList;
import java.util.List;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name ="sqlmapType", propOrder = { "sql" })
@XmlRootElement(name = "sqlmap")
public class Sqlmap {
    @XmlElement(required = true)
    protected List<SqlType> sql;

    public List<SqlType> getSql() {
        if (sql == null) sql = new ArrayList<>();
        return sql;
    }
}
```

```java
package springbook.user.sqlservice.jaxb;

import javax.xml.bind.annotation.*;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "sqlType", propOrder = { "value" })
public class SqlType {
    @XmlValue
    protected String value;

    @XmlAttribute(required = true)
    protected String key;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }
}
```

```java
package springbook.user.sqlservice.jaxb;

import javax.xml.bind.annotation.XmlRegistry;

@XmlRegistry
public class ObjectFactory {
}
```

### 언마샬링

- `언마샬링(unmarshalling)`: JAXB에서 XML 문서를 읽어서 자바의 오브젝트로 변환하는 것을 일컫는 말.
- `마샬링(marshalling)`: JAXB에서 바인딩 오브젝트를 XML 문서로 변환하는 것을 일컫는 말. 자바오브젝트를 바이트 스트림으로 바꾸는 것을 직렬화라고 부르는 것과 비슷하다.

## 2.2 XML 파일을 이용하는 SQL 서비스

### SQL 맵 XML 파일

- 스프링의 설정파일에 `<map>`으로 만들어뒀던 SQL을 모두 옮겨 `sqlmap.xml`이란 파일을 작성한다.

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<sqlmap xmlns="http://www.epril.com/sqlmap"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.epril.com/sqlmap
                            http://www.epril.com/sqlmap/sqlmap.xsd">
    <sql key="userAdd">INSERT INTO users(id, name, password, level, login, recommend, email) VALUES(?, ?, ?, ?, ?, ?, ?)"</sql>
    <sql key="userGet">SELECT * FROM users WHERE id = ?"</sql>
    <sql key="userDeleteAll">DELETE FROM users"</sql>
    <sql key="userGetCount">SELECT COUNT(*) FROM users"</sql>
    <sql key="userGetAll">SELECT * FROM users ORDER BY id"</sql>
    <sql key="userUpdate">UPDATE users SET name = ?, password = ?, level = ?, login = ?, recommend = ?, email = ? WHERE id = ?"</sql>
</sqlmap>
```

### XML SQL 서비스

- `sqlmap.xml`에 있는 SQL을 가져와 DAO에 제공해주는 `SqlService` 인터페이스의 구현 클래스를 만들어본다.
- JAXB를 이용해 XML 문서를 언제 가져올지 생각해야 하는데, DAO가 SQL을 요청할 때마다 가져오는 건 비효율적이므로, 일단 생성자에서 SQL을 읽어와 내부에 저장해두는 초기 작업을 진행한다.
- JAXB 컴파일러가 생성해준 XML 문서 바인딩용 클래스가 있다. JAXB로 XML 문서를 언마샬링하면 SQL 문장 하나하나는 `Sql` 클래스의 오브젝트에 하나씩 담긴다. 이를 `Map` 타입의 오브젝트에 저장해두는 편이 좋다.

```java
public class XmlSqlService implements SqlService {
    private Map<String, String> sqlMap = new HashMap<>();

    public XmlSqlService() {
        String contextPath = Sqlmap.class.getPackage().getName();
        try {
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            InputStream is = UserDao.class.getResourceAsStream("springbook/user/dao/sqlmap.xml");
            Sqlmap sqlmap = (Sqlmap)unmarshaller.unmarshal(is);

            for (SqlType sql : sqlmap.getSql()) {
                sqlMap.put(sql.getKey(), sql.getValue());
            }
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public String getSql(String key) throws SqlRetrievalFailureException {
        if (!sqlMap.containsKey(key)) {
            throw new SqlRetrievalFailureException(key + "를 이용해서 SQL을 찾을 수 없습니다");
        }
        return sqlMap.get(key);
    }
}
```

- 이제 설정을 수정하여 `sqlProvider` 빈의 설정을 변경한다.

```xml
<!-- sqlService -->
<bean id="sqlService" class="springbook.user.sqlservice.XmlSqlService"></bean>
```

- 설정을 변경하고 테스트를 실행하면 되어야 하나 'http://www.epril.com/sqlmap' 이 존재하지 않기 때문에 언마샬링에 실패한다.

---
[Home](./index.md)
