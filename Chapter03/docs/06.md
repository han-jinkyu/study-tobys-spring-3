# 6. 스프링의 JDBCTEMPLATE

- 스프링이 제공하는 템플릿/콜백 기술을 살펴본다.
- `JdbcTemplate`는 Jdbc와 유사하지만 훨씬 강력하고 편리한 기능을 제공한다.

```java
public class UserDao {
    // ...
    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        // ...
    }
    //...
}
```

## 6.1 update()

- deleteAll()을 처음으로 변경해본다.
- `StatementStrategy::makePreparedStatement()` == `PreparedStatementCreator::createPreparedStatement()`

```java
public class UserDao {
    // ...
    public void deleteAll() throws SQLException {
        this.jdbcTemplate.update(connection -> connection.prepareStatement("DELETE FROM users"));
    }
    // ...
}
```

- `JdbcContext::executeSql()` == `JdbcTemplate::update()`

```java
public class UserDao {
    // ...
    public void deleteAll() {
        this.jdbcTemplate.update("DELETE FROM users");
    }
    // ...
}
```

- update()는 가변인자를 넘겨서 PreparedStatement에 순서대로 바인딩해주는 기능도 사용할 수 있다.

```java
public class UserDao {
    // ...
    public void add(final User user) {
        this.jdbcTemplate.update(
            "INSERT INTO users(id, name, password) VALUES(?, ?, ?)",
            user.getId(), user.getName(), user.getPassword());
    }
    // ...
}
```

### 6.2 queryForInt()

- getCount()는 SQL 쿼리를 실행하고 ResultSet을 통해 결과 값을 가져온다.
- 템플릿은 `query()` 메서드며, `PreparedStatementCreator` 콜백과 `ResultSetExtractor` 콜백을 파라미터로 받는다.

```java
public class UserDao {
    // ...
    public int getCount() {
        return this.jdbcTemplate.query(
                connection -> connection.prepareStatement("SELECT COUNT(*) FROM users"),
                resultSet -> {
            resultSet.next();
            return resultSet.getInt(1);
        });
    }
 }
```

- 이를 `queryForInt()`라는 메서드를 통해 한 줄로 바꿀 수 있다. (deprecated)
    - `queryForObject()`로 통일됨

```java
public class UserDao {
    // ...
    public int getCount() {
        return this.jdbcTemplate.queryForObject("SELECT COUNT(*) FROM users", Integer.class);
    }
 }
```

### 6.3 queryForObject()

- get() 메서드는 복잡한 User 오브젝트를 반환한다.
- 템플릿은 `queryForObject()` 메서드며, 가변인자와 `RowMapper` 콜백을 파라미터로 받는다.
    - `RowMapper`는 여러 행을 맵핑할 경우 여러 번 호출된다.

```java
public class UserDao {
    // ...
    public User get(String id) throws SQLException {
        return this.jdbcTemplate.queryForObject(
            "SELECT * FROM users WHERE id = ?",
            new Object[] { id },
            (resultSet, rowNum) -> {
                User user = new User();
                user.setId(resultSet.getString("id"));
                user.setName(resultSet.getString("name"));
                user.setPassword(resultSet.getString("password"));
                return user;
            });
    }
    // ...
}
```
- `RowMapper`가 호출되는 시점엔 이미 next()가 호출되었다.
- `queryForObject()`는 한 개의 로우만 얻을 것을 기대한다.
- 다만 데이터가 없을 경우 `EmptyResultDataAccessException`을 던지게 했는데 이를 고려해야 한다.
    - 이는 이미 queryForObject()가 예외를 던지도록 만들어져 있다.
    
---
[목록](./index.md)
