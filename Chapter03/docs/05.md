# 5. 템플릿과 콜백

- 지금까지 전략 패턴을 이용해 리팩토링했다. 
- 일정한 작업 패턴을 갖는 작업 흐름이 존재하고 그 중 일부분만 자주 바꿔서 사용해야 하는 경우 적합하다.
- 스프링에서는 이를 `템플릿/콜백 패턴`이라 부른다.

## 5.1 템플릿/콜백의 동작원리

- `템플릿`은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미에서 붙여졌다.
- `콜백`은 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트다.

### 템플릿/콜백의 특징

- 보통 단일 메서드 인터페이스를 사용한다. 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문이다.
- 콜백 인터페이스의 메서드에는 보통 파라미터가 있다.
- 템플릿/콜백 패턴의 일반적인 작업 흐름은 다음과 같다.
    - 클라이언트는 템플릿에서 실행될 콜백 오브젝트를 만들고 넘긴다.
    - 템플릿은 정해진 작업 흐름을 진행하다 참조정보를 가지고 콜백 오브젝트의 메서드를 소환한다.
    - 콜백은 여러 참조정보를 이용해 작업을 수행하고 결과를 템플릿에 돌려준다.
    - 템플릿은 콜백이 돌려준 정보를 가지고 작업을 마저 수행한다.

### JdbcContext에 적용된 템플릿/콜백

- 템플릿과 클라이언트가 메서드 단위인 것이 특징이다.
- JdbcContext의 workWithStatementStrategy() 템플릿은 리턴 값이 없는 단순한 구조다.
- 흐름이 복잡하면 한 번 이상 콜백을 호출하기도 하고 여러 콜백을 클라이언트로부터 받아 사용하기도 한다.


## 5.2 편리한 콜백의 재활용

- 템플릿/콜백 방식의 아쉬운 점은 DAO 메서드에서 매번 익명 내부 클래스를 사용하기 때문에 작성과 읽기가 불편하다는 점이다.

### 콜백의 분리와 재활용

- deleteAll()을 보면 고정된 SQL 쿼리를 하나 담아 PreparedStatement를 만드는 게 전부다.
- 즉 deleteAll()에서는 'DELETE FROM users'만 바뀐다. 분리가 가능하다는 것이다.

```java
public class UserDao {
    // ...
    public void deleteAll() throws SQLException {
        executeSql("DELETE FROM users");
    }

    private void executeSql(final String query) throws SQLException {
        jdbcContext.workWithStatementStrategy(c -> {
            PreparedStatement ps = c.prepareStatement(query);
            return ps;
        });
    }
    // ...
}
```

### 콜백과 템플릿의 결합

- 더 나아가 executeSql()을 템플릿 클래스 안으로 옮겨본다.

```java
public class JdbcContext {
    // ...
    public void executeSql(final String query) throws SQLException {
        workWithStatementStrategy(c -> {
            PreparedStatement ps = c.prepareStatement(query);
            return ps;
        });
    }
}
```

```java
public class UserDao {
    // ...
    public void deleteAll() throws SQLException {
        jdbcContext.executeSql("DELETE FROM users");
    }
    // ...
}
```

- 일반적으론 코드를 분리하는 것이 좋지만 이 경우는 응집력이 강하므로 모아둔다.
- add() 같은 경우도 이런 방법을 적용할 수 있으며 가변 파라미터를 통해 정의해도 좋다.

---
[목록](./index.md)
