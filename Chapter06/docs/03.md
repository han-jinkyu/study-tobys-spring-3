# 3. 다이내믹 프록시와 팩토리 빈

## 3.1 프록시와 프록시 패턴, 데코레이터 패턴

- 처음에 트랜잭션 경계설정 코드를 분리해냈을 떄, 단순히 확장을 고려해 전략 패턴을 사용했다.
- 전략 패턴을 이용해 트랜잭션 기능의 구현 내용을 분리했지만 트랜잭션을 적용한다는 것 자체는 코드에 그대로 남아있다.
- 트랜잭션 기능은 비즈니스 로직과는 성격이 다르기 때문에 적용 코드를 분리할 수 있었다. (`UserServiceTx`, `UserServiceImpl`)
- 분리된 부가기능을 가진 클래스(`UserServiceTx`)는 핵심기능을 가진 클래스를 사용하는 구조여야 한다.
- 이렇게 자신이 클라이언트가 사용하려는 대상인 것마냥 위장해서 요청을 받는 것을 `프록시(proxy)`라고 한다.
- 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 `타깃(target)` 혹은 `실체(real subject)`라고 한다.
- 프록시는 사용 목적에 따라 두 가지로 분류할 수 있다.
    1. 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서.
    2. 타깃에 부가적인 기능을 부여하기 위해서.
    
### 데코레이터 패턴

- 데코레이터 패턴은 타깃에 부가적인 기능을 **런타임 시**에 동적으로 부여하기 위해 프록시를 사용하는 패턴이다.
- 프록시가 한 개로 제한되지 않으며, 프록시가 직접 타깃을 사용하도록 고정할 필요도 없다. 프록시가 여러 개이기 때문에 단계적으로 위임하는 구조를 만들어야 한다.
- 프록시로 동작하는 데코레이터는 위임 대상에도 인터페이스로 접근하기 때문에 위임 대상이 최종인지 아닌지도 알지 못한다.
- 자바 IO 패키의 `InputStream`, `OutputStream`이 대표적인 예다.

```
InputStream is = new BufferedInputStream(new FileInputStream("file.txt"));
```

- `UserService` 언터페이스를 구현한 `UserServiceImpl`에 트랜잭션 부가기능을 부여하는 `UserServiceTx`를 추가한 것도 그 예다.

### 프록시 패턴

- **프록시**는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법의 총칭이며, **프록시 패턴**은 프록시를 사용하는 방법 중 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다.
- 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경한다.
- 따라서 타깃 오브젝트를 생성하기 복잡하다면 필요시점까지 생성하지 않는 편이 좋다.
- 하지만 타깃 오브젝트에 대한 레퍼런스가 미리 필요할 때도 있는데 이 때 프록시 패턴을 이용한다.
- 클라이언트에게 타깃에 대한 레퍼런스를 넘기지 않고 프록시를 넘긴다. 프록시의 메서드를 통해 동작을 요청하면 그 때 타깃 오브젝트를 생성해 위임하는 것이다.

---
[목록](./index.md)
