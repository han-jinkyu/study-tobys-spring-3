# 2. 고립된 단위 테스트

- 가장 편하고 좋은 방법은 가능한 한 작은 단위로 쪼개서 테스트를 진행하는 것이다.
- 실패했을 때 그 원인을 찾기 쉽기 때문이다.

## 2.1 복잡한 의존관계 속의 테스트

- `UserServiceTest`가 테스트할 대상인 `UserService`는 사용자 정보를 관리하는 비즈니스 로직을 구현한 코드다.
- 따라서 `UserService`의 코드가 바르게 작성되어 있다면 성공하고 아니면 실패한다.
- `UserService`는 `UserDao`, `TransactionManager`, `MailSender`에 의존하고 있는데, 테스트가 진행되는 동안에 같이 실행된다. 이들 오브젝트는 또 다른 오브젝트에 의존하고 있다.
- 즉 `UserService`를 테스트하는 것은 훨씬 더 많은 오브젝트와 환경 등을 함께 테스트하는 셈이다.
- 따라서 이런 테스트는 준비가 어렵고, 환경이 조금만 달라져도 동일한 테스트 결과를 내지 못할 수 있다.

## 2.2 테스트 대상 오브젝트 고립시키기

### 테스트를 위한 UserServiceImpl 고립

- `MailSender`에 적용했던 테스트 대역을 `UserDao`에도 적용할 수 있다.
- `UserServiceImpl`은 테스트가 진행될 때 사전에 테스트를 위해 준비된 동작만 하도록 만든 두 개의 목 오브젝트에만 의존하는, 완벽한 고립된 테스트 대상으로 만들 수 있다.
- `UserDao`는 테스트 대상 코드가 정상적으로 수행되게끔 하는 스텁이 아닌, 검증 기능까지 가진 목 오브젝트로 만든다. 이유는 고립된 환경에서 동작하는 `upgradeLevels()`의 테스트 결과를 검증할 방법이 필요하기 때문이다.
- `upgradeLevels()`는 리턴 값이 없으므로 검증할 수 없다. 그래서 이제까지는 DB에 갱신된 값을 직접 검증하였다.
- 그렇지만 고립된 테스트 방식으로 만든 `UserServiceImpl`은 아무리 수행되어도 DB에 값이 남지 않으므로 결과를 검증하기 쉽지 않다.
- 이럴 땐 협력 오브젝트인 `UserDao`에게 어떤 요청을 했는지 확인 작업이 필요하다. 즉 목 오브젝트가 필요하다.

### 고립된 단위 테스트 활용

- `upgradeLevels()`에 대한 테스트는 다섯 단계로 구성된다.

1. 테스트 실행 중에 `UserDao`를 통해 가져올 테스트 데이터를 DB에 넣는다.
2. 메일 발송 여부를 확인하기 위해 `MailSender` 목 오브젝트를 DI한다.
3. 실제 테스트 대상인 `userService`의 메서드를 실행한다.
4. 결과가 반영되었는지 DB에서 데이터를 가져와 확인한다.
5. 목 오브젝트를 통해 `UserService`에 의한 메일 발송이 있었는지를 확인한다.

- 1번은 의존관계 마지막에 등장하는 DB를 준비하는 반면, 2번은 테스트를 고립시키도록 테스트만을 위한 목 오브젝트를 준비한다.
- 4번은 의존관계에 따라 DB를 확인하는 반면, 5번은 메일 서버까지 가지 않고 목 오브젝트를 통해 메일 발송 요청이 있었는지만 확인한다.

---
[목록](./index.md)